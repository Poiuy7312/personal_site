[
  {
    "objectID": "index.html#about-me",
    "href": "index.html#about-me",
    "title": "Preston Smith",
    "section": "About Me",
    "text": "About Me\nDescription I’m a Software Engineering Major and Art,Science and Innovation Minor at Allegheny College class of 2026. I hope to work in the video game industry which spurred my interest in computers.I also like to Make digital Collages in Photoshop and Illustrator which are normally inspired by videogames or movies"
  },
  {
    "objectID": "index.html#education",
    "href": "index.html#education",
    "title": "Preston Smith",
    "section": "Education",
    "text": "Education\n\nPittsburgh Science and Technology Academy (2018-2022)\nMajor: Computers and Connections\n\n\nAllegheny College (2022-2026)\nMajor: Software Engineering\nMinor: Art, Science and Innovation"
  },
  {
    "objectID": "index.html#skills",
    "href": "index.html#skills",
    "title": "Preston Smith",
    "section": "Skills",
    "text": "Skills"
  },
  {
    "objectID": "index.html#recent-posts",
    "href": "index.html#recent-posts",
    "title": "Preston Smith",
    "section": "Recent Posts",
    "text": "Recent Posts\n\n\n\n\n\nDate\n\n\nTitle\n\n\nAuthor\n\n\n\n\n\n\nFeb 3, 2025\n\n\nLog Analyzer\n\n\nPreston Smith\n\n\n\n\nDec 4, 2024\n\n\nRust based Password Checker and Authenticator\n\n\nPreston Smith\n\n\n\n\nOct 5, 2024\n\n\nTag Game\n\n\nPreston Smith\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "projects/Software Engineering/rust_password.html",
    "href": "projects/Software Engineering/rust_password.html",
    "title": "Rust based Password Checker and Authenticator",
    "section": "",
    "text": "This is a program that takes a username and password and stores it for later use it’s programmed in the rust programming language. This is due to it’s fast compile time and guaranteed memory safety in it’s program. This was mostly a project to create something that simulates password storage between a server and client.\n\nFeatures\n\nExtensive user interface\nCreated passwords must follow certain rules in order to be valid\nStores passwords as a hash using the argon2 hashing algorithm\nEnd to end encryption between the server and client\n\n\n\nExample of TUI\n\n\n\nRatutui\n\n\nThe user interface is made using the rust crate ratatui.\n\n\nHow it works\nThe program communicates with a socket server after the user types in there username and password. It sends the information to the server and gets a response to a server which will either create an account or if the password doesn’t follow rules like must be eight characters and must have a capital letter for example.\nPassword-Check"
  },
  {
    "objectID": "projects/Game Design/Golem.html",
    "href": "projects/Game Design/Golem.html",
    "title": "Golem",
    "section": "",
    "text": "Golem is a Twine based adventure game that I developed for one of my classes in college. It’s about a golem that is created by a town who’s only purpose is to serve the town and is punished for disobeying the town.\nGolem"
  },
  {
    "objectID": "projects/Game Design/Golem.html#description",
    "href": "projects/Game Design/Golem.html#description",
    "title": "Golem",
    "section": "",
    "text": "Golem is a Twine based adventure game that I developed for one of my classes in college. It’s about a golem that is created by a town who’s only purpose is to serve the town and is punished for disobeying the town.\nGolem"
  },
  {
    "objectID": "projects/Game Design/Golem.html#features",
    "href": "projects/Game Design/Golem.html#features",
    "title": "Golem",
    "section": "Features",
    "text": "Features\n\nMultiple Boss fights\nShops and Minigames\nRandomized Quests\nTurn based Combat System\nMultiple Endings\nDifferent Classes and play styles\n\nKnight - Regenerates Health\nMage - Has different interactions around the world and can read books\nThief - Gains more damage as the game goes on\n\n\n\n\n\n\n\n\n\n\n\nClasses\n\n\n\n\n\n\n\nBossfight\n\n\n\n\n\n\n\n\n\nDice\n\n\n\n\n\n\n\nCombat"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blog",
    "section": "",
    "text": "Log Analyzer\n\n\n\n\n\n\nSoftware Engineering\n\n\n\nAnalyzes and plots data from log files. based in rust\n\n\n\n\n\nFeb 3, 2025\n\n\nPreston Smith\n\n\n\n\n\n\n\n\n\n\n\n\nRust based Password Checker and Authenticator\n\n\n\n\n\n\nSoftware Engineering\n\n\n\nStores usernames and passwords and with end to end encryption between a simple server and client.\n\n\n\n\n\nDec 4, 2024\n\n\nPreston Smith\n\n\n\n\n\n\n\n\n\n\n\n\nTag Game\n\n\n\n\n\n\nGame Design\n\n\n\nA simple pygame where you run away from the AI chasing you.\n\n\n\n\n\nOct 5, 2024\n\n\nPreston Smith\n\n\n\n\n\n\n\n\n\n\n\n\nCHKN Golfing language\n\n\n\n\n\n\nSoftware Engineering\n\n\n\nGolfing language based on the lox interpreter\n\n\n\n\n\nMay 10, 2024\n\n\nPreston Smith\n\n\n\n\n\n\n\n\n\n\n\n\nChasten\n\n\n\n\n\n\nSoftware Engineering\n\n\n\nChecks for patterns in codes using x-path expressions\n\n\n\n\n\nSep 15, 2023\n\n\nPreston Smith\n\n\n\n\n\n\n\n\n\n\n\n\nGolem\n\n\n\n\n\n\nGame Design\n\n\n\nWeb-based game made in twine for a college project\n\n\n\n\n\nMay 9, 2023\n\n\nPreston Smith\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "projects/Game Design/tag.html",
    "href": "projects/Game Design/tag.html",
    "title": "Tag Game",
    "section": "",
    "text": "This Was a class project turn personal project as I wasn’t really satisfied with the final result. I mostly made the game more visually appealing made it so you didn’t have to rerun the script anytime you died and fixed some bugs with the obstacles.\nThis project was mostly to explore pathfinding in algorithms. I wanted to explore the A* star algorithm in this case and I wanted to make a game that was similar to snake at least in presentation.\n\n\n\nOriginally the game had no obstacles to run into outside the end of the board. This made it no only that A* was slow but also didn’t even come up with a better result than a simple greedy first algorithm. I then added in randomly appearing obstacles and for the most part a greedy algorithm was still better and faster on average. The problem with A* wasn’t that it couldn’t find a path but that it would stop the flow of the game to do it. So my compromise for this was to have the AI to change algorithms depending on the situation. I wanted to achieve two things with this first make it so A* has a purpose in this game as pretty much a final resort. But also I didn’t want to make it so the AI simply chased you so Instead I changed the greedy algorithm to go to the point the player is heading if it’s a certain distance away. It will also only use A* if the player isn’t moving. This made the AI more fun to play against while also allowing to handle certain edge cases better with A*.\n\n\n\n\n\n\n\n\n\nTitle\n\n\n\n\n\n\n\n\nTag-game\n\n\n\nThis shows an early state of the game as the game continues more obstacles will appear which are the black squares.\n\n\n\n\n\n\n\nYou are the green square and your goal is to survive as long as possible and in turn earn as many points as possible.\n\nYou lose if the red square catches you\n\n\n\n\nW: Go up A: Go left S: Go down D: Go right\n\nIf you’ve ever played snake it moves very similar where you go in the direction of key you press until you specify otherwise.\n\n\n\n\n\n\n\nThe game generates a board of forty by forty with the starting location of the player being opposite of each other. Everything in this game is coordinate based and stores obstacles coordinates, player coordinates and enemy coordinates and changes the color of the associated square depending on those locations\n  tile_size = width / board_size\n        tile_origin = (0, 0)\n        tiles = []\n        for i in range(board_size):\n            row = []\n            for j in range(board_size):\n                rect = pygame.Rect(\n                    tile_origin[0] + j * tile_size,\n                    tile_origin[1] + i * tile_size,\n                    tile_size,\n                    tile_size,\n                )\n                if (i, j) == user.location:\n                    # Draw Player character\n                    pygame.draw.rect(screen, \"green\", rect)\n                elif (i, j) == enemy.location:\n                    # Draw Enemy\n                    pygame.draw.rect(screen, \"red\", rect)\n                elif (i, j) in obstacles:\n                    # Draw Obstacle\n                    pygame.draw.rect(screen, \"black\", rect)\n                else:\n                    pygame.draw.rect(screen, \"orange\", rect, 1)\n                row.append(rect)\n            tiles.append(row)\n\n\n\nThe player is a class and is the simplest part of the program it has a location and direction.\n\nLocation: Current location of player\nDirection: Direction player is currently moving\n\nAll the program does is respond to key presses and changes the direction and location accordingly.\nclass player:\n    def __init__(self, location: Tuple[int, int], direction: str | None):\n        self.location = location\n        self.direction = direction\n\n    def move_player(self, obstacles) -&gt; bool:\n        \"\"\"Changes player coordinates depending on current direction.\"\"\"\n        result = None\n        if self.direction == \"Up\" and self.location[0] &gt; 0:\n            result = (self.location[0] - 1, self.location[1])\n        elif self.direction == \"Down\" and self.location[0] &lt; 40:\n            result = (self.location[0] + 1, self.location[1])\n        elif self.direction == \"Left\" and self.location[1] &gt; 0:\n            result = (self.location[0], self.location[1] - 1)\n        elif self.direction == \"Right\" and self.location[1] &lt; 40:\n            result = (self.location[0], self.location[1] + 1)\n        if result != None and result not in obstacles:\n            self.location = result\n            return True\n        self.location = self.location\n        return False\n\n\n\nThe enemy is also a class similar to an enemy however it is much more complex and uses different algorithms to choose it’s next move depending on the location.\n\n\nA* works by assigning a value to each possible moves based on how far away it is from the goal in this case we use manhattan distance which is just rise + run. It will make an estimate on how many moves it should take and will calculate it’s path based on that however if it runs into a move that would get it closer but is not possible due to some other factor it will recalculate and try the current move that as the lowest value.\ndef pathfinder(\n        self, obstacles, start: Tuple[int], goal: Tuple[int]\n    ) -&gt; Tuple[int, int]:\n        # A* pathfinding algorithm to find the best path from start to goal\n        if not Path(self.filename).exists() or Path(self.filename).stat().st_size == 0:\n            open_list = []  # List of nodes to explore\n            closed_list = set()  # Set of explored nodes\n            start_node = Node(start, None, 0, self.distance_from_player(start, goal))\n            heapq.heappush(open_list, start_node)  # Add the start node to the open list\n\n            while open_list:\n                current_node = heapq.heappop(\n                    open_list\n                )  # Get the node with the lowest f cost\n                if current_node.position == goal:\n                    path = self.reconstruct_path(\n                        current_node\n                    )  # Reconstruct path if goal is reached\n                    with open(self.filename, \"w\") as fh:\n                        for p in path:\n                            fh.write(f\"{p}\\n\")  # Write path to file\n                    break\n\n                closed_list.add(\n                    current_node.position\n                )  # Mark the current node as explored\n                neighbors = self.possible_moves(\n                    current_node.position, obstacles\n                )  # Get valid neighbors\n                for next_position in neighbors:\n                    if next_position in closed_list:\n                        continue  # Skip if the neighbor has already been explored\n                    assert (\n                        next_position not in closed_list\n                    )  # Ensure neighbor is not in closed list\n                    g_cost = current_node.g + 1  # Increment cost from the start\n                    h_cost = self.distance_from_player(\n                        next_position, goal\n                    )  # Heuristic cost\n                    next_node = Node(next_position, current_node, g_cost, h_cost)\n\n                    if self.add_to_open(open_list, next_node):\n                        heapq.heappush(\n                            open_list, next_node\n                        )  # Add to open list if it's a better path\n\n\n\nGreedy search is much simpler and is used most of the time in this program. All it does is check all the possible moves which at most is four at one time and if it gets closer to the player then it will do that and if theres multiple that get closer it will randomly choose one.\n if self.location != goal:  # If the enemy is not at the goal\n            for move in moves:\n                new_dist = self.distance_from_player(\n                    move, goal\n                )  # Calculate new distance to goal\n                if new_dist &lt; current_distance:\n                    current_distance = new_dist  # Update current distance if closer\n                    best_moves.add(move)  # Add to best moves\n                else:\n                    bad_moves.add(move)  # Add to bad moves\n\n            # Choose the best move if available\n            if moving:\n                if best_moves:\n                    self.location = random.choice(\n                        list(best_moves)\n                    )  # Move to a best move\n                    if os.path.exists(self.filename):\n                        os.remove(self.filename)  # Remove path file\n                    return None\n\n                else:\n                    black_list = self.location\n                    self.location = random.choice(\n                        list(bad_moves)\n                    )  # Move to a random bad move if no best options"
  },
  {
    "objectID": "projects/Game Design/tag.html#description",
    "href": "projects/Game Design/tag.html#description",
    "title": "Tag Game",
    "section": "",
    "text": "This Was a class project turn personal project as I wasn’t really satisfied with the final result. I mostly made the game more visually appealing made it so you didn’t have to rerun the script anytime you died and fixed some bugs with the obstacles.\nThis project was mostly to explore pathfinding in algorithms. I wanted to explore the A* star algorithm in this case and I wanted to make a game that was similar to snake at least in presentation.\n\n\n\nOriginally the game had no obstacles to run into outside the end of the board. This made it no only that A* was slow but also didn’t even come up with a better result than a simple greedy first algorithm. I then added in randomly appearing obstacles and for the most part a greedy algorithm was still better and faster on average. The problem with A* wasn’t that it couldn’t find a path but that it would stop the flow of the game to do it. So my compromise for this was to have the AI to change algorithms depending on the situation. I wanted to achieve two things with this first make it so A* has a purpose in this game as pretty much a final resort. But also I didn’t want to make it so the AI simply chased you so Instead I changed the greedy algorithm to go to the point the player is heading if it’s a certain distance away. It will also only use A* if the player isn’t moving. This made the AI more fun to play against while also allowing to handle certain edge cases better with A*."
  },
  {
    "objectID": "projects/Game Design/tag.html#display",
    "href": "projects/Game Design/tag.html#display",
    "title": "Tag Game",
    "section": "",
    "text": "Title\n\n\n\n\n\n\n\n\nTag-game\n\n\n\nThis shows an early state of the game as the game continues more obstacles will appear which are the black squares."
  },
  {
    "objectID": "projects/Game Design/tag.html#game-play",
    "href": "projects/Game Design/tag.html#game-play",
    "title": "Tag Game",
    "section": "",
    "text": "You are the green square and your goal is to survive as long as possible and in turn earn as many points as possible.\n\nYou lose if the red square catches you\n\n\n\n\nW: Go up A: Go left S: Go down D: Go right\n\nIf you’ve ever played snake it moves very similar where you go in the direction of key you press until you specify otherwise."
  },
  {
    "objectID": "projects/Game Design/tag.html#how-it-works",
    "href": "projects/Game Design/tag.html#how-it-works",
    "title": "Tag Game",
    "section": "",
    "text": "The game generates a board of forty by forty with the starting location of the player being opposite of each other. Everything in this game is coordinate based and stores obstacles coordinates, player coordinates and enemy coordinates and changes the color of the associated square depending on those locations\n  tile_size = width / board_size\n        tile_origin = (0, 0)\n        tiles = []\n        for i in range(board_size):\n            row = []\n            for j in range(board_size):\n                rect = pygame.Rect(\n                    tile_origin[0] + j * tile_size,\n                    tile_origin[1] + i * tile_size,\n                    tile_size,\n                    tile_size,\n                )\n                if (i, j) == user.location:\n                    # Draw Player character\n                    pygame.draw.rect(screen, \"green\", rect)\n                elif (i, j) == enemy.location:\n                    # Draw Enemy\n                    pygame.draw.rect(screen, \"red\", rect)\n                elif (i, j) in obstacles:\n                    # Draw Obstacle\n                    pygame.draw.rect(screen, \"black\", rect)\n                else:\n                    pygame.draw.rect(screen, \"orange\", rect, 1)\n                row.append(rect)\n            tiles.append(row)\n\n\n\nThe player is a class and is the simplest part of the program it has a location and direction.\n\nLocation: Current location of player\nDirection: Direction player is currently moving\n\nAll the program does is respond to key presses and changes the direction and location accordingly.\nclass player:\n    def __init__(self, location: Tuple[int, int], direction: str | None):\n        self.location = location\n        self.direction = direction\n\n    def move_player(self, obstacles) -&gt; bool:\n        \"\"\"Changes player coordinates depending on current direction.\"\"\"\n        result = None\n        if self.direction == \"Up\" and self.location[0] &gt; 0:\n            result = (self.location[0] - 1, self.location[1])\n        elif self.direction == \"Down\" and self.location[0] &lt; 40:\n            result = (self.location[0] + 1, self.location[1])\n        elif self.direction == \"Left\" and self.location[1] &gt; 0:\n            result = (self.location[0], self.location[1] - 1)\n        elif self.direction == \"Right\" and self.location[1] &lt; 40:\n            result = (self.location[0], self.location[1] + 1)\n        if result != None and result not in obstacles:\n            self.location = result\n            return True\n        self.location = self.location\n        return False\n\n\n\nThe enemy is also a class similar to an enemy however it is much more complex and uses different algorithms to choose it’s next move depending on the location.\n\n\nA* works by assigning a value to each possible moves based on how far away it is from the goal in this case we use manhattan distance which is just rise + run. It will make an estimate on how many moves it should take and will calculate it’s path based on that however if it runs into a move that would get it closer but is not possible due to some other factor it will recalculate and try the current move that as the lowest value.\ndef pathfinder(\n        self, obstacles, start: Tuple[int], goal: Tuple[int]\n    ) -&gt; Tuple[int, int]:\n        # A* pathfinding algorithm to find the best path from start to goal\n        if not Path(self.filename).exists() or Path(self.filename).stat().st_size == 0:\n            open_list = []  # List of nodes to explore\n            closed_list = set()  # Set of explored nodes\n            start_node = Node(start, None, 0, self.distance_from_player(start, goal))\n            heapq.heappush(open_list, start_node)  # Add the start node to the open list\n\n            while open_list:\n                current_node = heapq.heappop(\n                    open_list\n                )  # Get the node with the lowest f cost\n                if current_node.position == goal:\n                    path = self.reconstruct_path(\n                        current_node\n                    )  # Reconstruct path if goal is reached\n                    with open(self.filename, \"w\") as fh:\n                        for p in path:\n                            fh.write(f\"{p}\\n\")  # Write path to file\n                    break\n\n                closed_list.add(\n                    current_node.position\n                )  # Mark the current node as explored\n                neighbors = self.possible_moves(\n                    current_node.position, obstacles\n                )  # Get valid neighbors\n                for next_position in neighbors:\n                    if next_position in closed_list:\n                        continue  # Skip if the neighbor has already been explored\n                    assert (\n                        next_position not in closed_list\n                    )  # Ensure neighbor is not in closed list\n                    g_cost = current_node.g + 1  # Increment cost from the start\n                    h_cost = self.distance_from_player(\n                        next_position, goal\n                    )  # Heuristic cost\n                    next_node = Node(next_position, current_node, g_cost, h_cost)\n\n                    if self.add_to_open(open_list, next_node):\n                        heapq.heappush(\n                            open_list, next_node\n                        )  # Add to open list if it's a better path\n\n\n\nGreedy search is much simpler and is used most of the time in this program. All it does is check all the possible moves which at most is four at one time and if it gets closer to the player then it will do that and if theres multiple that get closer it will randomly choose one.\n if self.location != goal:  # If the enemy is not at the goal\n            for move in moves:\n                new_dist = self.distance_from_player(\n                    move, goal\n                )  # Calculate new distance to goal\n                if new_dist &lt; current_distance:\n                    current_distance = new_dist  # Update current distance if closer\n                    best_moves.add(move)  # Add to best moves\n                else:\n                    bad_moves.add(move)  # Add to bad moves\n\n            # Choose the best move if available\n            if moving:\n                if best_moves:\n                    self.location = random.choice(\n                        list(best_moves)\n                    )  # Move to a best move\n                    if os.path.exists(self.filename):\n                        os.remove(self.filename)  # Remove path file\n                    return None\n\n                else:\n                    black_list = self.location\n                    self.location = random.choice(\n                        list(bad_moves)\n                    )  # Move to a random bad move if no best options"
  },
  {
    "objectID": "projects/Software Engineering/chasten.html",
    "href": "projects/Software Engineering/chasten.html",
    "title": "Chasten",
    "section": "",
    "text": "I mostly worked on trying to implement the program with an LLM to generate x-path expressions to be used. as well as some minor bug fixes\nchasten create-checks\nWhich will then display a textual app the code for which is in the configApp.py file:\n\nApp Example\n\n\n\nTextual\n\n\nIt will also prompt for an API key if one has not been given already just through a terminal input which it will then store an encrypted version into a text file using fernet.\nThe code than takes the inputs given by the user and stores it in a csv file split that information up when then the app is closed and use the write_checks function in configApp.py to format it in way to have consistently formatted inputs to send to chatGPT in an attempt to make the program more consistent.\nIt then displays the checks and sends the information to chatGPT and gets the results which is handled in the createchecks.py file and then displays the results in the terminal and stores it in a YAML file called checks.yml or whatever the user specify.\n\n\nOutput Example\n\n\n\nimage_2023-11-21_150812765\n\n\nChasten"
  },
  {
    "objectID": "projects/Software Engineering/log_analyzer.html",
    "href": "projects/Software Engineering/log_analyzer.html",
    "title": "Log Analyzer",
    "section": "",
    "text": "This is a program that reads a log file in a the standard format. It then counts the users, errors, total number of logs, bytes transferred and avg bytes transferred. Currently a work in progress"
  },
  {
    "objectID": "projects/Software Engineering/log_analyzer.html#description",
    "href": "projects/Software Engineering/log_analyzer.html#description",
    "title": "Log Analyzer",
    "section": "",
    "text": "This is a program that reads a log file in a the standard format. It then counts the users, errors, total number of logs, bytes transferred and avg bytes transferred. Currently a work in progress"
  },
  {
    "objectID": "projects/Software Engineering/log_analyzer.html#features",
    "href": "projects/Software Engineering/log_analyzer.html#features",
    "title": "Log Analyzer",
    "section": "Features",
    "text": "Features\n\nCumulative vs Time:\n\nCumulative\n\nCumulative means you can choose two different data points in compare i.e. total logs and errors. it adds them together cumulatively and currently tracks it every minute by default.\n\n\nCumulative Plot:\n\n\n\ncplot\n\n\n\n\n\nTime\n\nTime tracks one specified point of data over a specified period i.e. errors per hour or avg bytes per hour.\n\n\n\n\nDisplay different plots\nCurrently only one plot can be made at a time you can chose the x and y axis or if you just want to track something based on time then you pick the y axis.\n\nSort by Time:\nCurrently the logs can be sorted by second up to year. For example if you want to sort them by an hour then the graph the results will have points of data that have been collected over an hour. The data given will be errors occurred with in the hour, avg bytes transferred by hour.\n\n\nTime Plot:\n\n\n\nplot\n\n\nLog Analyzer"
  },
  {
    "objectID": "art.html",
    "href": "art.html",
    "title": "Art",
    "section": "",
    "text": "I create art where you are meant to imagine yourself within the art and the world that it’s supposed to represent. I’m heavily influenced by different fantasy Videogames Berzerk and on a lesser level differing movie scenes and the emotions they invoke. As a result of this my art and what is included in it is heavily influenced by what I’m interested in at the time. I’ll often see something in a Videogame or in a movie and wonder what that would look like if it were in the real world or something similar. My process of working is very much thinking about what I want to see in the work and then trying to implement it as best as possible so while it starts with a general Idea it normally evolves into something with other elements to it. I view my process as a form of world building as while it stems from, I think this is cool so I’ll just put it in there. I do normally think about a situation where it would exist within the context of the work. I normally view the work as a somewhat fractured world where different spaces and ideas are interacting and colliding. I like art to be vibrant so I can see the differences more clearly, and it draws my attention to things I wouldn’t normally notice even when I’m the one making it."
  },
  {
    "objectID": "art-projects/187/art-2022.html",
    "href": "art-projects/187/art-2022.html",
    "title": "Things From the Future Project",
    "section": "",
    "text": "Apocalypse 1\n\n\n\n\n\n\n\nApocalypse 2\n\n\n\n\n\n\n\nApocalypse 3"
  },
  {
    "objectID": "art-projects/580/580.html",
    "href": "art-projects/580/580.html",
    "title": "Imagined Worlds Exhibition",
    "section": "",
    "text": "Encroaching Fire\n\n\n\n\n\n\n\nFloating City\n\n\n\n\n\n\n\n\n\nRaided Village\n\n\n\n\n\n\n\nFractured Worlds"
  },
  {
    "objectID": "art.html#artist-statement",
    "href": "art.html#artist-statement",
    "title": "Art",
    "section": "",
    "text": "I create art where you are meant to imagine yourself within the art and the world that it’s supposed to represent. I’m heavily influenced by different fantasy Videogames Berzerk and on a lesser level differing movie scenes and the emotions they invoke. As a result of this my art and what is included in it is heavily influenced by what I’m interested in at the time. I’ll often see something in a Videogame or in a movie and wonder what that would look like if it were in the real world or something similar. My process of working is very much thinking about what I want to see in the work and then trying to implement it as best as possible so while it starts with a general Idea it normally evolves into something with other elements to it. I view my process as a form of world building as while it stems from, I think this is cool so I’ll just put it in there. I do normally think about a situation where it would exist within the context of the work. I normally view the work as a somewhat fractured world where different spaces and ideas are interacting and colliding. I like art to be vibrant so I can see the differences more clearly, and it draws my attention to things I wouldn’t normally notice even when I’m the one making it."
  },
  {
    "objectID": "art.html#works",
    "href": "art.html#works",
    "title": "Art",
    "section": "Works",
    "text": "Works\n\n\n\n\n\n\n\n\n\n\nImagined Worlds Exhibition\n\n\n\n\n\n\nJunior Year(2025)\n\n\n\nJunior year art project\n\n\n\n\n\nApr 22, 2025\n\n\nPreston Smith\n\n\n\n\n\n\n\n\n\n\n\n\nOther Projects\n\n\n\n\n\n\nFreshman Year(2022)\n\n\n\nOther stand alone projects\n\n\n\n\n\nMar 25, 2023\n\n\nPreston Smith\n\n\n\n\n\n\n\n\n\n\n\n\nThings From the Future Project\n\n\n\n\n\n\nFreshman Year(2022)\n\n\n\nA visualization of an apocalyptic future (Digital Collage)\n\n\n\n\n\nFeb 20, 2023\n\n\nPreston Smith\n\n\n\n\n\n\n\n\n\n\n\n\nHistorical Minecraft Villager Documentary\n\n\n\n\n\n\nFreshman Year(2022)\n\n\n\nFreshman year art project (Video)\n\n\n\n\n\nJan 15, 2023\n\n\nPreston Smith\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "art-projects/580/580.html#artist-statement",
    "href": "art-projects/580/580.html#artist-statement",
    "title": "Imagined Worlds Exhibition",
    "section": "Artist Statement",
    "text": "Artist Statement\nJunior year art project"
  },
  {
    "objectID": "art-projects/187/villager_video.html#description",
    "href": "art-projects/187/villager_video.html#description",
    "title": "Historical Minecraft Villager Documentary",
    "section": "Description",
    "text": "Description\nThis was a project I made freshman year of collage. I wanted to make a parody of documentaries and I thought the way that minecraft villagers are treated in the game was a good thing to make it on. Because if you think about it the way villagers are normally used in a minecraft world is actually quite cruel."
  },
  {
    "objectID": "projects/Software Engineering/chkn.html",
    "href": "projects/Software Engineering/chkn.html",
    "title": "CHKN Golfing language",
    "section": "",
    "text": "This was a very rudimentary language designed for golfing. It was based on the lox interpreter and includes loops strings integers string concantetation. Some limitation it doesn’t include data structures which can heavily inflate the byte count for certain golf challenges."
  },
  {
    "objectID": "projects/Software Engineering/chkn.html#description",
    "href": "projects/Software Engineering/chkn.html#description",
    "title": "CHKN Golfing language",
    "section": "",
    "text": "This was a very rudimentary language designed for golfing. It was based on the lox interpreter and includes loops strings integers string concantetation. Some limitation it doesn’t include data structures which can heavily inflate the byte count for certain golf challenges."
  },
  {
    "objectID": "projects/Software Engineering/chkn.html#examples",
    "href": "projects/Software Engineering/chkn.html#examples",
    "title": "CHKN Golfing language",
    "section": "Examples",
    "text": "Examples\nV: c = 0. W: (c&lt;10)c++ P: \"*\"*10.;\nOutput:\n**********\n**********\n**********\n**********\n**********\n**********\n**********\n**********\n**********\n**********\nC: a(b,c)W:(c!=b)P:\"lox\"*c.I:(b&lt;1)c--;E: c++;;;a(6,1)a(0,4)\nOutput:\nlox\nloxlox\nloxloxlox\nloxloxloxlox\nloxloxloxloxlox\nloxloxloxlox\nloxloxlox\nloxlox\nlox"
  },
  {
    "objectID": "art-projects/580/580.html#description",
    "href": "art-projects/580/580.html#description",
    "title": "Imagined Worlds Exhibition",
    "section": "Description",
    "text": "Description\nThese are digital collages that are meant to recreate a feeling or tone I felt while playing through a game and/or watching a specific scene in a movie there supposed to be reminiscent of cinematic shots while also being distinct environment in and of themselves. Originally they were going to form some sort of narrative which I found tedious and restricted my creativity in a way. They were all made with a combination of Photoshop and illustrator with photos from unsplash and concept art from differing games and movies."
  },
  {
    "objectID": "art-projects/580/580.html#exhibition-photos",
    "href": "art-projects/580/580.html#exhibition-photos",
    "title": "Imagined Worlds Exhibition",
    "section": "Exhibition Photos",
    "text": "Exhibition Photos"
  },
  {
    "objectID": "art-projects/580/580.html#images",
    "href": "art-projects/580/580.html#images",
    "title": "Imagined Worlds Exhibition",
    "section": "",
    "text": "Encroaching Fire\n\n\n\n\n\n\n\nFloating City\n\n\n\n\n\n\n\n\n\nRaided Village\n\n\n\n\n\n\n\nFractured Worlds"
  },
  {
    "objectID": "art-projects/580/580.html#exhibition-images",
    "href": "art-projects/580/580.html#exhibition-images",
    "title": "Imagined Worlds Exhibition",
    "section": "Exhibition Images",
    "text": "Exhibition Images"
  },
  {
    "objectID": "art-projects/187/art-2022.html#description",
    "href": "art-projects/187/art-2022.html#description",
    "title": "Things From the Future Project",
    "section": "Description",
    "text": "Description\nI didn’t really start out with a general idea at first. I knew I wanted to do stuff with caves and something a bit weird. I ended up getting stuff which I think has a kind of a religious vibe and they all have kind of a hellish landscape. To me they have a tone of unsettling and despair. It’s not clear what is happening in the collage so I think a lot of it is up to interpretation but the coloring and I think kind of pushes the tone into unsettling and despair and it gives a hellish look. I used statues as my object because I wanted to stuff with scale for the most part and I think statues are a good way to do that and kind of just have a large object. All of these combined kind of made so I the arc of it all is a society that collapsed at least a thousand years in the future. The objects in the picture themselves don’t really serve a purpose in context. Because I thought of them as things people built for some cultural reason but not really anything practical and since it collapsed I wanted people to be kind of exploring them in there kind of ruins of a former civilization that collapsed long enough ago that people don’t know much about them so the people in the future don’t know much more than people actually looking at the collages. Overall The backstory of the collages are heavily up to interpretation but I think they all give off the same type of vibe."
  }
]